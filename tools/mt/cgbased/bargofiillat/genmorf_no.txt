#!/usr/bin/perl -w
# -*- mode: cperl; indent-tabs-mode: nil; tab-width: 3; cperl-indent-level: 3; -*-
BEGIN { $| = 1; }
use utf8;

#########################################################################
#### genmorf_no: Morphological generator script after smecg.norsyn.cg
#### © GrammarSoft ApS 2018; contact: eckhard.bick @ mail.dk
#########################################################################
#
# input:
# 	     cat sme.dep | cg3 -g ~/parsers/sme/etc/smecg.nor.cg | niceline.perl
#       | sme2nor --l | cg3 -g cglex.txt
#       | cg3 -g ~/parsers/sme/etc/smecg.norsyn.cg | niceline_mt
#       | genmorf_no | trad2inline.pl --p
#
# Input format is "niceline" cg, with wordform and (only) one reading on the same line, containing sme wordform and nor lemma. Must contain relevant nor tags, but remaining sme tags don't hurt. No strict fst tag order is needed
#
# The script looks up an fst-analysis for the lemma, harvests inflexion information from the input, and adapts fst tags accordingly, then pipes back the tag string to the fst for generation  
#
#########################################################################

use String::Approx 'amatch';
#use String::Levenshtein qw(distance prefix_distance);
use DB_File;
use DBM_Filter;
use Encode;

use IPC::Run qw( start pump finish ); # interprocess communication
my ($binDir, $sep) = $0 =~ /^(.*)(\\|\/).*/;
my $bindir = $binDir;
#print "--$bindir\n";
my $af_in;
my $af_out;
my $af_err;
my $af_h;
my $af_started = 0;

my $lvs = "/usr/local/visl/bin/levenshtein.pl";
if (-s "$bindir/levenshtein.pl") {
   $lvs = "$bindir/levenshtein.pl";
}
eval(require $lvs);
if ($@) {
    print "Couldn't load levenshtein.pl!\n";
    return -1;
}

sub explode_utf8 {
    my ($line) = @_;
    while ($line =~ m@([^\x{00}-\x{7E}])@) {
        my $code = $1;
        my $ord = ord($1);
        $line =~ s/\Q$code\E/\\u{$ord}/g;
    }
    return $line;
}

sub implode_utf8 {
   my ($line) = @_;
   while ($line =~ m@\\u\{(\d+)\}@) {
      my $code = $1;
      my $chr = chr($1);
      $line =~ s/\\u\{$code\}/$chr/g;
   }
   return $line;
}

sub initNorAnalyzer {
#   print STDERR "$0 initNorAnalyzer enter\n";
   my @af_cmd = ($binDir . '/nor.analyzer.wrapper');
   $af_h = start \@af_cmd, \$af_in, \$af_out, \$af_err;

   $af_in = "oqaatsit\n";
   pump $af_h until $af_out =~ /\n\n/g;
   $af_out = '';
   $af_started = 1;
#   print STDERR "$0 initNorAnalyzer exit\n";
}
if (1==2) {print $af_err;} # to prevent "used-only-once" warnings in Perl

sub callNorAnalyzer {
   if (!$af_started) {
      # Protect against endless recursion
      if (defined $ENV{NORANALYZER_SUBCHAIN} && $ENV{NORANALYZER_SUBCHAIN} == 1) {
         return $_[0];
      }
      $ENV{NORANALYZER_SUBCHAIN} = 1;
      initNorAnalyzer();
   }
   my ($input) = @_;
   $input =~ s/^\s//g;
   $input =~ s/\s$//g;
   $input =~ s/\s+/ /g;

   $input = explode_utf8($input);
#   print STDERR "$0 callNorAnalyzer input: $input\n";
   $af_in .= $input;
   $af_in .= "\n";
   pump $af_h until $af_out =~ /\n\n/g;
   my $out = $af_out;
   $out = implode_utf8($out);
   $af_out = '';
   $out =~ s/^\s+//g;
   $out =~ s/\s+$//g;
#   print STDERR "$0 callNorAnalyzer output: $out\n";
   return $out;
}
if (1==2) {print $afg_err;} # to prevent "used-only-once" warnings in Perl

sub initNorGenerator {
#   print STDERR "$0 initNorGenerator enter\n";
   my @afg_cmd = ($bindir.'/nor.generator.wrapper');
   $afg_h = start \@afg_cmd, \$afg_in, \$afg_out, \$afg_err;

   $afg_in .= "__SENTINEL__\n";
   pump $afg_h until $afg_out =~ /__SENTINEL__/g;
   $afg_out = '';
   $afg_started = 1;
#   print STDERR "$0 initNorGenerator exit\n";
}

sub callNorGenerator {
   if (!$afg_started) {
      # Protect against endless recursion
      if (defined $ENV{NORGENERATOR_SUBCHAIN} && $ENV{NORGENERATOR_SUBCHAIN} == 1) {
         return $_[0];
      }
      $ENV{NORGENERATOR_SUBCHAIN} = 1;
      initNorGenerator();
   }
   my ($input) = @_;
   $input =~ s/^\s//g;
   $input =~ s/\s$//g;
   $input =~ s/\s+/ /g;

   $input = explode_utf8($input);
#   print STDERR "$0 callNorGenerator input: $input\n";
   $afg_in .= $input;
   $afg_in .= "\n";
   $afg_in .= "__SENTINEL__\n";
   pump $afg_h until $afg_out =~ /__SENTINEL__/g;
   my $out = $afg_out;
   $out = implode_utf8($out);
   $afg_out = '';
   $out =~ s/__SENTINEL__.*$//sg;
   $out =~ s/^\s+//g;
   $out =~ s/\s+$//g;
#   print STDERR "$0 callNorGenerator output: $out\n";
   return $out;
}

sub first_file {
   foreach my $f (@_) {
      if (-e $f && -s $f) {
         return $f;
      }
   }
   die("No such file\n");
}

my $lexDir = "$binDir/../lex";

my $Ttrad = tie %trad, "DB_File", first_file("$lexDir/sme.nor.dict.db", "/home/eckhard/parsers/kal/lex/kal.dan.dict.db"), O_RDONLY;
$Ttrad->Filter_Push('utf8');

if (1==2) {print %trad;} # to prevent "used-only-once" warnings in Perl

$num=0;

while (<>) {
   if (/ \#1->/ && $num) {
      &process;
      $num =0;
      @lines = ();
   }
   $lines[$num] =$_;
   $num++;
}
if ($num) {&process;}

sub process {
   $i=-1; $i_root=0;
   foreach(@lines) {
      $i++;
#      print "--her: $_\n";

      if (/<NO:(.*?)>/ || /[ \t]["\[]([^<]*?)["\]] /) {
         $line = $_;
         $trans =$1;
         $trans =~ s/=/ /g;
         if (/^.*? ([A-Z]+|Pron|Det|Adv|Art) /) {
            $pos =$1;
         }
         else {
            $pos = "X";
         }
#         print "--**$trans, $pos\n";
         $cohort = callNorAnalyzer($trans);
# 	      print "--cohort= $cohort\n";
         if ($cohort !~ /\+\?/) {
            @readings = split "\n", $cohort;
         #		$norfst="xxx";
            $norfst=$readings[0];
#            print "---$norfst\n";
            foreach (@readings) {
               if (/\+([A-Z]+|N|V|A|Adv|Part|Pron|[Dd]et|Art)(\+[0-9]?[A-Z][a-z][A-Za-z]*[0-9]?)*(\+[A-Z][A-Z]+)*$/) {$posfst=$1;}
               else {$posfst = "X";}
               if ("\L$pos" eq "\L$posfst" && ! /\+(Gen|Acc|Pl)(\+.*)?$/ && ! ($posfst eq "V" && ! /\+Inf/) && ! ($line =~ /<insert>/ && /\tén\+/)) {
                  $norfst=$_;
#                  print "--choosing $norfst\n";
                  next;
               } #
            }
            $norfst =~ s/.*\t//;
            if ($pos eq "Art") {$norfst =~ s/é/e/;}

            $norfst =~ s/\+[^\+]+\/[^\+]+//g; # remove secondary tags

            $form[$i] = $norfst;
            if ($form[$i] =~ s/(\+([A-Z]+|[NV]|Adv|Part|Prop))((\+[0-9]?[A-Z]+[a-z][A-Za-z]*)*)$/¤$1$3/) {
               $i_root =$i;
               $pos = $1;
               $flex = $3;

               &checkinflexion;

               if ($flex) {
                  $form[$i] =~ s/¤.*$/¤$pos$flex/;
               }
#            print "--$form[$i]\n";
            }
         }
         else {
            $form[$i] = $trans;
         }
      }
   }

   $i=-1;
   foreach (@lines) {
      $i++;
      if (! $form[$i]) {goto printout;} # <...> lines and empty lines
      if ($form[$i] =~ /^(.+)=([^=]+(¤.+)?)$/) {
         $fullform =$2;
         $first =$1;
      }
      else {
         $fullform = $form[$i];
         $first = "";
      }

      if ($fullform && $fullform=~ /\+/) {
#         print "--fullform=$fullform\n";
         $fullform =~ s/¤//g;
         $fst_call = callNorGenerator($fullform);
         if ($fst_call =~ /\+\?/) {
            $fst_call = callNorGenerator("\l$fullform");
         }
         if ($fst_call =~ /\+\?/) {
            $fullform =$trans;
         }
         else {
#            print "--fst_call (gen): $fst_call\n";
            @fst_forms = split /\n/, $fst_call;
            $fullform = $fst_forms[0];
#         print "----" . $fst_forms[0] . "...\n";
            foreach (@fst_forms) { # which one to choose, if there is more than one possible fullform?
#            print "--form=$_\n";
            }
            $fullform =~ s/\n.+//g;
            $fullform =~ s/.*\t//;
            if ($first) {
               $fullform = $first . "=" . $fullform;
            }
         }
      }
    printout:
      if ($fullform) {
         $fullform =~ s/ /=/g;
         s/<NO:.*?> *//;
         s/(["\]]) /$1 <NO:$fullform> /;
      }
      print;
   }
}

sub checkinflexion {

### nouns

   if (/ (Gen|Acc|Nom) /) { # nob non-Nom cases
      $case = "\u\L$1";
      $flex =~ s/\+Nom/\+$case/;
      #               print "--new case: $case\n";
   }
   if (/ (Sg|Pl) /) {
      $number = $1;
      $flex =~ s/\+Sg/\+$number/;
   }
   if (/ (Def) /) {
      $def = $1;
      $flex =~ s/\+Indef/\+$def/;
   }

### verbs

   if (/ (Prs|Prt) /) {
      $tense = "$1";
      $flex =~ s/\+Inf/\+Inf+$tense/;
   }
   if (/ (Ind|Subj) /) {
      $mood = "\u\L$1";
      $flex =~ s/\+Inf/\+$mood/;
   }
#   print "--mood=$mood, flex=$flex\n";
   if (/ (Sg[1-3]|Pl[1-3]) /) {
      $pn = $1;
      $flex =~ s/(Sg|Pl)[1-3]/\+$pn/;
   }
}
print "\n"; # last empty line necessary to trigger printing of last sentence in trad2linline.pl
