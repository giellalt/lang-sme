!!!Free and Open source Finnish analyser gtsvn-fi

;Authors: Divvun and Giellatekno teams, Aajege, community members
;Software version: 2012
;Documentation license: GNU GFDL
;SVN Revision: $Revision: 68217 $
;SVN Date: $Date: 2013-01-16 11:31:33 +0200 (Wed, 16 Jan 2013) $

!!!GTSVN-sma

This is free and open source South Sámi morphology.
Divvun & Giellatekno - open source grammars for Sámi and other languages

















=== Tags for Inflection ===



















































!!!DELIMITERS 



!!!TAGS AND SETS


!!Sets containing lists of tags






* Sets for parts of speech






* Sets for POS sub-categories





* Sets for Semantic tags






* Sets for Morphosyntactic properties






























* Sets for Derivation






* Sets for Syntactic tags


























* Sets for Single-word sets






!!Sets containing sets of lists and tags


* Sets for word or not




* Derivational affixes







* Case sets





* Verb sets



* Sets for finiteness and mood











* Sets for person















* Sets consisting of forms of "leat" (these ones need to be rewritten)




* Pronoun sets














* Adjectival sets and their complements








* Adverbial sets and their complements










* Sets for coordinators








* Sets for adverbs that have lookalikes














* Sets of elements with common syntactic behaviour


* Sets for verbs
** V is all readings with a V tag in them, REAL-V should
be the ones without an N tag following the V.  
The REAL-V set thus awaits a fix to the preprocess V ... N bug.



* The set COPULAS is for predicative constructions













TRANS-V is the set for verbs really taking objects

* Sets for verbs choosing oblique objects or adverbials




STRICT-TRANS-V is the set for verbs which don't leat a GenAcc be a modifyer of anything else than an object, e.g. Mun organiseren eatni gievkkanis. - eatni wants to be the object

























* Valency sets



































































* Adverb sets









* Adjective sets






















* NP sets defined according to their morphosyntactic features









* The PRE-NP-HEAD family of sets

These sets model noun phrases (NPs). The idea is to first define whatever can
occur in front of the head of the NP, and thereafter negate that with the
expression __WORD - premodifiers__.











The set __NOT-NPOD__ is used to find barriers between NPs.
Typical usage: ... (*1 N BARRIER NPT-NPMOD) ...
meaning: Scan to the first noun, ignoring anything that can be
part of the noun phrase of that noun (i.e., "scan to the next NP head")






* Other negatively defined morphosyntactic noun sets












* Noun sets

Nominal sets defined according to their morphophonological properties
Sets for lexeme homonymy (most of them are moved to where the actual rules are.)


The words in the set __N-PO__ can be both N and Po, the set takes that into account.


* The LAHKA set family





















* Nominal sets defined according to their semantical properties


* Spatial noun sets. These nouns behave like postpositions




* Time sets































* Amount sets

















* Sets for nouns with morpho-syntactic preferences

* Number-related sets






* Sets for case, possessive, etc.














* Sets for nouns as pred






































* Sets for animals













* Sets for things
























* Sets for qualities


* Sets for things, not necessarily tools



















* Sets for things such that people can be inside them:

* Sets for things such that people cannot be inside them:






* Part-whole sets for human




* Sets for places




























* Sets that can both be buildings/places and represent humans

























































* Sets denoting relations





* Miscellaneous sets



















* Border sets and their complements














* Syntactic sets




These were the set types.



!!!DISAMBIGUATION RULES  


!!!SECTION 1, THE SECTION FOR POPULAR RULES 



!!Propernouns

*Selects __Prop__ if capital letter inside clause

*Removes __PropAttr__ if no Prop on the right side

*Removes __PropPl__

*Substitute __PlcSur__ (Plc) (Sur) 


!!Other popular rules?

 * Remove ABBR, e.g. "dii" N ABBR Nom

 * __Dert__ Rule for removing Der/t Prop when there are other analysis

 * Rules for removing Prop


* Removes __viibmat__ 

* Removes __dussat__ 



!!!ONE-COHORT DISAMBIGUATION - CYCLE 0

The idea behind "cycle 0" is to have safe rules without context first.
These rules typically chose lexicalisations over derivations, 
Saami words instead of marginal names, etc.

!!Lexicalised derivations

* Removes __derV__  DER-V if lexicalised.

*Removes __derN__ if lexicalised.

*Removes __derNEss__ if lexicalised, and both nouns are essive.

*Removes __derA__ or PrsPrc or VGen if lexicalised. VGen is a chance.

* Removes __derVhmm__ Does this function?

* __derHderAlla__ removes Der/h Der/alla if Der/halla.

* __derAlla__ removes Der/halla if Der/alla.

* Removes __derH__ if Der/goahti.  

* Removes __derST__ if Der/ahtti	

* __derVuohta__ removes A Attr Der/vuohta if A Der/vuohta.	


!!Adjectives or nouns, not adverbs

* __Aifeambbo__ selects A after eambbo


* __muhtunlagan__ removes lága Ess if Indef ja lágan A

!!Adverbs


!Lexicalised adverbs


!Adverbs, not nouns or adjectives

* __AdvNotNA__ Adverbs, not nouns or adjectives


* __birrasii__ removes birrasii N


* __eambbogo__ selects Adv eambbo go

!!Pronouns 

* __recipr, reciprPl__ select Recipr



!!Nouns

!Not noun


!!Not adposition

* The rules __Pooaivai, Pogiedas__ removes oaivái and gieđas as Po

!!Not Qst

* __AdvQst__ removes dego/nugo Qst 


!!Interj: 

* __Interjlemma__ voja voja nana nana select interj if repeated 



!!Southern Locative vs. Essive

* __SouthLoc__ removes Southern Locative vs. Essive

!!Px-rules for special nouns

* __NnoPx__ Remove Px for special nouns


* __gaskaneaset__ selects Po for gaskaneaset	

!!Some verb rules

* __vfingo__ selects VFIN in front of go Qst


!Particular verbs

* __leapmaDimin__ removes it

* __Der/PassS__ removes some of them which are not likely at all



* __LEX-PASS__ removes passive forms of some lemmas in favour for the lexixalised one



* __Ger and GER-NOTV__ remove Ger-forms which are not likely at all





!Particular CS

* __madeCS__ for mađe/mađi and dađe/dađi

* __dadeCS__ for mađe/mađi and dađe/dađi



!!!SECTION 2: LOCAL DISAMBIGUATION - CYCLE 1



!!FAMILY pronouns

* __moai__ This rule is not in use because of REMOVE:Prop


* __miiPers__



















* dasa ( = forms of the verb "dassat"): __dasaVGen, dasaLassin__



* __datSg3__ selects if there is no Pl3-verb, and in front of Rel Sg, and if the next word is not N 

* __datSg3PrfPrc__ selects dat in front of leamaš



* __datPersCopulas__ select Pers in front of copula. I setninger som Riššat dat gal leat musge, jus eai leačča njuoskan. tolker jeg dat som Pcle. Derfor constraint hva som kommer etter.

* __datPcle1__ selects dat Pcle between N and finite, even if there is agreement between verb and dat .

* __datPcle2__ selects dat Pcle when there is no agreement between verb and dat .

* __KilldatPcle__ removes the remaining dat Pcle


* __PersAcc__ selects Pers Acc in accusativ infinitive clauses with object


* __datPers__ selects Pers. I made it stronger than it was. ref. r897 in sme-dis.rle

* __datDemSg__ selects Dem from Pron Pers Sg3 Gen

* __datPersPl3__ selects dat Pl3 in front of V Pl3 and V Du3 and Rel Pl


!!An early rule for "eanaš"/"eanas"

* __eanasPron__ selects Pron in front of Pron Loc

!!Px constraints 
First select Px, then remove all remaining Px

* Nouns: __NomPxSg1__ (not Ess) as the only word in a sentence. Needs no disambiguation. Should it have N-PX as constraint?

* Nouns:  __AccPxSg1__ after a TV verb. Exception for Aux.

* Nouns:  __AccPxSg1__ after a TV Inf verb.


* __PxSg1LocAcc__ is Acc to the right.

* __PxSg1Acc__ is Acc to the right.


* coordination __PxSg1coord__ 

* __PxSg1coordLast__ for the last word of a coordination

* Nouns: __PxSg2__ if SG2-V. The rule needs no disambiguation. The DON-constraint because of homonymi with (N Pl)

* __PxSg2Acc__ if  TV to the right

* __PxSg2AccImprt__ if  TV Imprt to the left

* __PxSg2AccPrfPrc__ after PrfPrc 

* __PxSg2GenPo__ if in front of Po, after til verb

* __PxSg3Loc__ after habitivconstruction

* Nouns: __PxSg3Acc__ if Sg3 or Sg to the left

* Nouns: __PxSg3AccPrfPrc__ if PrfPrc and Sg3 to the left

*  __PxSg3CC__ in coordination with the owner

*  __PxSg3GenPo1__ in front of Po, to the left of the owner

*  __PxSg3GenPo2__ in front of Po, to the left of the owner

* __Genguossis__ is  selection Gen, not only with Px. The FAMILY-set would be better than Hum-tag, but there is often a propernoun connected to the noun. guossái and guossis should have Po analysis?

* __GenNPFinal__ selects Gen as the modifier of a noun in the end of a sentence.

* __PxSg3Nom__ is waiting for changes in FST: oahpaheaddji and hearrá with Px Sg3 Nom

* I don't know what this is for. I'll let it be here for a while to see if it will be used for the corpus.



We end section 2 by removing all remaining Px

* __KillPx__ removes all remaining Px readings


!!SECTION 3: Certain verb readings


* __NotVGenIfDer__ removes VGen if 0 = Der/Pass or Der...(r947)


!All imperatives

* __NotImprtIfRel__ removes Imprt after Rel, unify this with other left context (r948)


!Sg1 - early cycle, safe rules

* __VSg1IfLeftMun__ selects Sg1 when "mun" is to the left (r949)

* __VSG1IfRightMun__ selects Sg1 when "mun" is to the right (r950)


!Sg2 - early cycle, safe rules


* __VSG2IfLeftDon__ selects Sg2 when "don" is to the right (r951)

* __VSG2IfRightDon__ selects Sg2 when "don" is to the left (r952)

* __VInfIfAhte__ removes Inf if there is no other VFIN between BOS and "ahte" (r953)


!Sg3 - early cycle, safe rules

* __VSG3IfLeftSon__ selects Sg3 when "son" is to the left (r954)

* __VSG3IfRithgSon__ selects Sg3 when "son" is to the right (r954)

* __VNotSg3When12Left__ removes Sg3 if 12 Pron immediate left (r955)

* __VNotSg3IfCom__ removes Sg3 in X with Y is... (r957)



* __NegSg3BeforeFoc__ selects Neg before Foc/ge or ConNeg (r959)

Negative verb, not abbreviation or roman numeral Ii.

!Du1 - early cycle, safe rules

These Du1, Du2 rules are (almost) not in use in our corpus, but we keep them for completeness.

* __VDu1IfMoaiLeft__ selects Du1 when "moai" left (r960)

* __VDu1IfMoaiRight__ selects Du1 when "moai" right (r961)


!Du2 - early cycle, safe rules

The next two rules are not found in the corpus, but logically
they belong, to cover the whole paradigm. There is no verb-internal
homonymy here, but there is homonymy with e.g. Illative for certain verbs.

* __VDu2IFDoaiLeft__ selects Du2 if "doai" to the left (r962)	 

* __VDu2IFDoaiRight__ selects Du2 if "doai" to the right (r963)	 

!Du3 - early cycle, safe rules

The competitor to Du3 is -ba Foc.

* __VDu3IfSoaiLeft__ selects Du3 when "soai" left (r964)

* __VDu3IFSoaiLeft__ selects Du2 if "doai" to the right (r965)	 

* __VDu3IfGuokteLeft__ selects Du3 if "guokte" left (r966) - 15

* __VDu3IfGuokteRight__ removes Sg3 if "guokte" right and 0 Du3 (r967)

* __VDu3IfNjaNLeft__ selects Du3 as verb with coordinated subject to the left (r968) - 43

* __VDu3IfNjaNRight__ selects Du3 as verb with coordinated subject to the right (r969) - 12

* __VDu3IfCollLeft__ hmm, remove this?

!Pl1 - early cycle, safe rules

The competitor here is obviously Inf, but also Pl3 and Prt Sg2.

* __VPl1IfMiiLeft__ selects Pl1 if "mii" Pron to the left (r971) - 3163

* __VPl1IfMiiRight__ selects Pl1 if "mii" Pron to the right (r972) - 272

* __VPl1NotImprIfMiiLeft__ removes Imprt if if "mii" Pron to the left and 0 = "mii" (r973) - 557

!Pl2 - early cycle, safe rules

These rules are not used when disambiguating the corpus
* __VPl2IfDiiLeft__ selects Pl2 if "dii" Pron to the left (r974) - 0

* __VPl2IfDiiRight__ selects Pl2 if "dii" Pron to the right (r975) - 0


!Pl3 - early cycle, safe rules

Select...

* __r976__ SE V Pl1 if *-1 SII

* __r977__ SE V Pl1 if *1 SII

* __VPl3jaPl3__ selects Prt Pl3 in coordination (r978)


The following two may be joined:

* __VPl3IfPronRelLeft1__ selects Pl3 if -1 Rel is linked to -2 Pl (r979) - 7801

* __VPl3IfPronRelLeft2__ selects Pl3 if -1 Rel is linked via COMMA to -3 Pl (r980) - 853

* __VPl3IfCSLinkPl3Left__ selects Pl3 if -1 Rel is linked via COMMA to -3 Pl (r979) - 341


Remove...


The following two may be joined:

* __r982__ removes Prt Sg2 if Pl3 subject - 6002

* __r983__ removes Prt Sg2 if Pl3 subject via CS - 305

* __VPl3Lookalikes__ removes "verbs" like "manne" and "dušše" (r984) - 274

* __VPl3NotSg2BefPassive__ removes Sg2 for Pl3 and Inf before passive (r985)

!PrsPrc

* __r986__ selects PrsPrc if coordinated with A - 10
Early rule since many PrsPrc readings are removed later.



!!!SECTION 4: CYCLE 1B: REMOVING THE READINGS THAT WERE LEFT FROM THE 1A RULES 

!!We don't need more Px sections, it's done alrady: Removing (nearly) all remaining Px reading 

!!Noun, adjectiv, PrsPrc or not?



* __NnotAcoord__ selects N instead of A, based on coordination with N, and a vfin-verb

* __NPlbeforeRel, NSgbeforeRel__ select N in front of Rel and MO


!!Adjectives and adverbs


!!Disambiguationg abbreviations


!!Disambiguationg particles

* __sonPcle__ selects son Pcle, the remaining Pcle are removed



!!Disambiguationg numerals


!!Disambiguationg adpositions

!Rules relating to particular adpositions

!!Some particular subjunctions and Neg Sup

* __amasCS__ selects CS, not A or Neg Sup

* __amasA__ selects A, not CS or Neg Sup

* __amasNegSup__ selects Neg Sup, not CS or A

* __amatNegSup__ selects Neg Sup, not CS

* __dasgoCS__ selects CS, not Qst

* Removes __vaikkoAdv__ , it is always CS because of abbr: "vaikko_mii" Pron Indef

!!go as CS and Qst Pcle
First select all "go" Qst Pcle, then remove them so the rest will be "go" CS

* __standQst__ selects Pcle in standard questions

* __objQst__ selects Pcle in questions which function as object in the clause

* __subQst__ selects Pcle in questions as subordinated clause

* __vaiQst__ selects Pcle in questions with vai

* __auxQst__ selects Pcle in questions as subordinated clause, starting with AUX

* __refQst__ selects Pcle in two main clauses, the first one a question which is referred to in the second.

* __nounQst__ selects Pcle for go after noun

* __poQst__ selects Pcle for go after Po

* __killPcle__ removes all remaining Pcle for go 


!!!SECTION 9 WORD-SPECIFIC RULES


!!Some particular subjunctions

!!Adverb rules

!!!MAPPING OF COMP-CS< , COMPLEMENTS OF PARTICLES IN COMPARISON
First map all COMP-CS<, then remove the other readings

* __ComptimeAdvl__ buoret go ovdal

* __Compadvlcase__ eará sivas go fuorrávuođas

* __Compvejolas__ go vejolaš

* __compNomHead__ NP-HEAD-NOM (ADVL) go NP-HEAD-NOM (ADVL). VFIN-NOT-IMPRT pga manglende disamgiguering

* __CompNomHead__ Comp NP-HEAD-NOM leat go NP-HEAD-NOM  


* __compMisc__ go geassebuođut, go dán áigge

* __compInf__ Inf go Inf


* __Compdego__ dego @COMP-CS<

* __compAccdego__ Acc dego Acc

* __compTVeambbo__ TRANS-V eambbo go Num Acc + Gen


* __compCoord__ coordination	

* __compCoordAttr__ coordination again, now with Attr. Speacial rule because of that Attr also has other readings.	


* __killAllnotComp__ Removes analysis which are not @COMP-CS<

** ''This was the kill all not Comp rule!!''

* __goCSbeforeComp__ Selects CS analysis in front of @COMP-CS<

!!!MAPPING OF CC AND CS

Mostly we map both @CNP and @CVP, then we select @CNP, after that we remove them so @CVP remains

* __cnpCompSC__ Map @CNP if @COMP-CS< or COMPAR ahte


* __CSasCNPCVP__ Map some CSs both @CNP @CVP

* __CSasCVP__ Map @CVP to CS

* __CCasCNPCVP__ Map (@CNP @CVP) to CC

* __ahteCNP__ ahte CC @CNP, remove the rest

* __killAllahtenotCS__ All other occurrences of "ahte" are CSs.

* __vaiCCCNP__ vai as CC or CS

* __vaiCC__ remove vai as CC 

* __vaiCCNegQst1__ vai CC @CVP before Neg or question

* __vaiCCNegQst2__ vai CC @CNP in question about two alternatives

* __killAllvainotCSCVP__ Select all vai CS @CVP	

* __dadeCNP__ removes dađe @CNP, so @CVP remains

* __CVPnoVfin__ No potential finite verb following

* __CVPnoVfinAdvl__ No finite verb in front ADVLCASE @CNP ADVLCASE	

* __CVPNPron__ No finite verb or verbalactivity in front N/Pron @CNP N/Pron	

* __CVPAdvNom__ Nom @CNP Adv Nom	

* __CVPCopNomInf__ COPULAS Nom @CNP Nom Inf	


 *__CVPoppramsing__ Lásse, Iŋgá ja mun


*__CVPRCmpnd__ RCmpnd @CNP

* __CVPwrongCmpnd__ wrongly formated compounds

* __CVPAAttr__ A Attr @CNP A Attr	

* __CVPA__ A @CNP A 	


* __CVPAccAdv__ Acc @CNP Adv Acc	



* __killAllCNP__ removes all remaining @CNP

* __XCC-CS__ removes CC and CS with no synttag



!!!PRONOUNS

!!Interrogative and relative pronouns

* __Interr__ selects interrogative pronouns in questions


* __InterrIfPot__ selects interrogative pronouns in potential sentences, and after that we remove the remaining Interr


* __munPl3__ removes Pron Pers Pl3 if there is no verb agreement

* __Rel__ selects Rel

* __RelSg1, RelSg2__ select Rel

* __RelPl__ selects Rel

* __RelPl__ removes Rel

!!Emphatic ieš     

* __ies1Pl, ies2Pl__ select Pl for ieža



* __iesDu__ select Pl for ieža


!!Numerals

* __NifNum__ 

* __AdvOvtta__ 

* __AdvNumEss__ 


!!Indefinite pronouns





















!!Demonstrative pronouns












!!Disambiguating adjectives 



* boaris A or N

* dološ 

* garra N vs. garas A

* nanus

* nuorra (vs. nuorrat V)


* sierra

* surgat

* veara


* vuolit
















!!!MISC 
!!And now some rules for adverbs that modify adjectives
!!Proper nouns

!!!VERBS

!!Disambiguating verbs - part 1 

First ConNeg forms, they are dependent upon Neg verbs. Then Imperative 
(with their special syntax), infinitive, and other infinite forms. 
Person comes later (in part 2)




!!ConNeg forms

Number following the rule headers below refer to numbers of hit in a 13 053 859 word corpus.

* __ConNegImp__ selects ConNeg Imprt if Neg Imprt to the left. - 4265

* __ConNegIfNeg__ selects Ind ConNeg if Neg Ind to the left. This is the main (and common) ConNeg rule. - 660327

* __ConNegCondIfNeg__ selects Cond ConNeg if Neg Cond to the left. Less used, obviously. - 0

* __ConNegPrfPrc__ selects ConNeg for leat when topicalised PrfPrc between Neg and leat - 713

* __ConNegImpCC__ catches the second ConNeg in cases like don't smile or laugh - 0

* __ConNegIndCC__ catches the second ConNeg in cases like doesn't smile or laugh - 369

* __NotConNegII__ removes ConNegII if no Neg Imprt around. This is important, as the homonym forms are common. - 30850

* __NotConNegIfNotNeg__ removes ConNeg if no Neg to the left. Consider unifying with NotConNegNotNeg. - 1094269

* __NotConNegNotNeg__ removes remaining ConNegs whenever no Neg to the left. - 5862






!!Imperative

See also ''Imprt or Ind'' some sections down.

* __ImprtLeat__ says BOS Leat A is Imprt - 575

* __ImprtDál__ 


* __ImprtComma__ 

* __ImprtNotVGen__

* __NotImprtInd__ 

* __NotImprtConNeg__ 

* __NotImprtA__ 

* __NotImprtN__ 


* __NotImprtVFIN__ 


* __NotImprtSlash__ 


* __NotImprtGo__ 


!!Infinitive

This section still not evaluated

* __r1809__ Not Pl1 (but Inf) if VFIN to the left, This is the basic Inf rule.

* __InfCompCs__ 

* __r1811__ 

* __r1812__ 

* __r1813__ 

* __r1814__ 

* __r1815__ 



Rules that prevent later selection of Inf for a finite verb in the frame 						  
''INF-V...CC...''

* __r1816__ 
* __r1817__ 

* __r1818__ 
* __r1819__ 


* __r1820__ 

* __r1821__ 



* __r1822__ 

* __r1823__ 

* __r1824__ 

* __r1825__ 

* __r1826__ 

* __r1827__ 
* __r1828__ 

* __r1829__ 

* __r1830__ 

* __r1831__ 

* __r1832__ 

* __r1833__ 


!!Verbgenitive
!!Supinum vs. potential
!!Perfect Participle
!!Actio
!!Present participle
*orrut vs. orrot) 
!!Rules for "addit" (which is an adjective, but more often a verb)
!!Actio Loc = Actio Ess
!!Actio Gen = Actio Ess
!!Imprt or Ind



* __removeAllImp__

!!Nouns or verbs







!!Demonstrative pronouns, agreement in DP - should it be moved to after verbmappings? 




!!!VERB MAPPINGS



!!Verbs as predicatives (@SPRED>) and (@<OPRED) 

!(@SPRED>) and (@<OPRED) target  PrfPrc































































* __FMAINVaux__ finite AUX-OR-MAIN verbs     

* __FMAINVcop__ finite COPULAS verbs     

* __FAUXVaux__ finite AUX  verbs     

* __FAUXVaux__ infinite AUX verbs     

* __FMAINVcopInfconstr__ finite leat before Inf     



* __FMAINVcopMannan__ finite leat before mannan TIME     

* __FMAINVHabconstr__ finite in habitive constructions    

* __FMAINVCoopCoord__ finite 

* __FAUXVleat__ finite 

* __FMAINVAux1__ finite 

* __FMAINVAux2__ infinite 

* __FAUXVCop__ finite copulas coming after the mainverb

* __FAUXVCop__ finite copulas coming before the mainverb

* __FAUXVboahtit__ finite boahtit coming before the mainverb

* __FMAINVCop__ finite copulas 	

* __FMAINV__ finite to the remaining finite verbs which are not AUX    

* __FAUXVConNegCop__ infinite to ConNeg COPULAS   

* __FAUXVConNegAux__ infinite to ConNeg AUX-OR-MAIN   

* __FMAINVConNeg__ infinite to ConNeg   

* __FMAINVConNeg__ infinite to ConNeg

* __FMAINVConNegCop__ infinite to ConNeg COPULAS   

* __FAUXVConNegAux__ infinite to ConNeg AUX   

* __FAUXVPrfPrcAux__ infinite to PrfPrc AUX  before Inf or Actio Ess

* __FMAINVPrfPrc__ infinite to PrfPrc 

* __FMAINVPrfPrcEss__ infinite to PrfPrc before Ess

* __FMAINVPrfPrcleat__ infinite to PrfPrc leat

* __FMAINVPrfPrcafterAuxAux__ infinite to PrfPrc after two Auxs

* __FMAINVPrfPrccoord__ infinite to PrfPrc coordination	

* __FMAINVPrfbeforeAux__ infinite to PrfPrc before the Aux	


* __FMAINVInf__ infinite to Inf

* __FMAUXVActioEss__ infinite to Actio Ess

* __FMAINVActioEss__ infinite to Actio Ess

* __FMAINVSup__ infinite to Sup

* __FAUXV__ to finite Aux








!!!NOUNS
!!Disambiguating nouns 
!!Nouns vs. adjectives
!!Disambiguating proper nouns 

!!!CASE DISAMBIGUATION

!!Secure rules for choosing Acc

!Intransitive verbs can sometimes be transitive






!Accusative or genitive in front of ALU and in front of adjectives






Exceptional accusative attributes in front of ALU nouns.
Not-so-exceptional?










!!Intransitive verbs can sometimes be transitive
!!Accusative or genitive in front of ALU and in front of adjectives
!!Accusative before @COMP-CS<
!!Accusative before some A
!!Accusative sentence-finally
!!Genitive and accusative in temporal adverbials
!!Choosing accusative or genitive semantically
!!Genitive

The most frequent genitive rule: Gen when postpos immediately to the right:



!!Nominative and accusative
!!Nominative

!!Accusative

!!Illative

!!Early comitative rules

!!Locative

!!Essive  
!!Late case rules (after other case rules have worked). 

!!!VERBS PART 2, SECTION #22


!!Finite or not



















































!!Indicative or imperative
!!Verbs according to person and number
!!Rules for a special infinitive construction
!!More finite verbs
!!Passive
!!Infinitive
!!Present Participle
!!Actio/Perfect Participle 
!!Actio
!!Selecting some more finite verbs
!!Lexical disambiguation of verbs 

!!!NOMEN
!!Case rules
!!Other rules for nouns and pronouns
!!Px rules
!!Determiners
!!Adverbs and adjectives

!!!NOUNS

!!!VERBS

!!!NOMEN


!!Genitive after preposition - round 2
*MAINLY MAPPING-RULES #####









