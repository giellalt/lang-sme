








!!!Delimiters 



!!!TAGS AND SETS


!!Sets containing lists of tags






* Sets for parts of speech






* Sets for POS sub-categories





* Sets for Semantic tags






* Sets for Morphosyntactic properties






























* Sets for Derivation






* Sets for Syntactic tags


























* Sets for Single-word sets






!!Sets containing sets of lists and tags


* Sets for word or not




* Derivational affixes






* Case sets





* Verb sets



* Sets for finiteness and mood











* Sets for person















* Sets consisting of forms of "leat" (these ones need to be rewritten)




* Pronoun sets














* Adjectival sets and their complements








* Adverbial sets and their complements










* Sets for coordinators








* Sets for adverbs that have lookalikes














* Sets of elements with common syntactic behaviour


* Sets for verbs
** V is all readings with a V tag in them, REAL-V should
be the ones without an N tag following the V.  
The REAL-V set thus awaits a fix to the preprocess V ... N bug.



* The set COPULAS is for predicative constructions













TRANS-V is the set for verbs really taking objects

* Sets for verbs choosing oblique objects or adverbials




STRICT-TRANS-V is the set for verbs which don't leat a GenAcc be a modifyer of anything else than an object, e.g. Mun organiseren eatni gievkkanis. - eatni wants to be the object

























* Valency sets



































































* Adverb sets









* Adjective sets






















* NP sets defined according to their morphosyntactic features









* The PRE-NP-HEAD family of sets

These sets model noun phrases (NPs). The idea is to first define whatever can
occur in front of the head of the NP, and thereafter negate that with the
expression __WORD - premodifiers__.











The set __NOT-NPOD__ is used to find barriers between NPs.
Typical usage: ... (*1 N BARRIER NPT-NPMOD) ...
meaning: Scan to the first noun, ignoring anything that can be
part of the noun phrase of that noun (i.e., "scan to the next NP head")






* Other negatively defined morphosyntactic noun sets












* Noun sets

Nominal sets defined according to their morphophonological properties
Sets for lexeme homonymy (most of them are moved to where the actual rules are.)


The words in the set __N-PO__ can be both N and Po, the set takes that into account.


* The LAHKA set family





















* Nominal sets defined according to their semantical properties


* Spatial noun sets. These nouns behave like postpositions




* Time sets































* Amount sets

















* Sets for nouns with morpho-syntactic preferences

* Number-related sets






* Sets for case, possessive, etc.














* Sets for nouns as pred






































* Sets for animals













* Sets for things
























* Sets for qualities


* Sets for things, not necessarily tools



















* Sets for things such that people can be inside them:

* Sets for things such that people cannot be inside them:






* Part-whole sets for human




* Sets for places




























* Sets that can both be buildings/places and represent humans

























































* Sets denoting relations





* Miscellaneous sets



















* Border sets and their complements














* Syntactic sets




These were the set types.




!!!DISAMBIGUATION RULES  
!!One-cohort disambiguation - cycle 0

!!The section for popular rules 
!Propernouns

*Selects __Prop__ if capital letter inside clause

*Removes __PropPl__

*Substitute __PlcSur__ (Plc) (Sur) 


!Lexicalised derivations
* Removes __derV__  DER-V if lexicalised.

*Removes __derN__ if lexicalised.

*Removes __derNEss__ if lexicalised, and both nouns are essive.

*Removes __derA__ or PrsPrc or VGen if lexicalised. VGen is a chance.

* Removes __derVhmm__ Does this function?

* __derHderAlla__ removes Der/h Der/alla if Der/halla.

* __derAlla__ removes Der/halla if Der/alla.

* Removes __derH__ if Der/goahti.  

* Removes __derST__ if Der/ahtti	

* __derVuohta__ removes A Attr Der/vuohta if A Der/vuohta.	


!Adjectives or nouns, not adverbs

* __muhtunlagan__ removes lága Ess if Indef ja lágan A

!Lexicalised adverbs
! __AdvNotNA__ Adverbs, not nouns or adjectives



* __eambbogo__ selects Adv eambbo go

!Lexicalized indefinite pronoun 

!Nouns

!Not noun

!Interj: 

* __Interjlemma__ voja voja nana nana select interj if repeated 



! __SouthLoc__ removes Southern Locative vs. Essive


! Px-rules for special nouns

* __NnoPx__ Remove Px for special nouns


* __gaskaneaset__ selects Po for gaskaneaset	
!Some verb rules
!Particular verbs

!!!Local disambiguation - cycles 1 and 2 
!!FAMILY pronouns
!!An early rule for "eanaš"/"eanas"
!!Px constraints 

* Nouns: __NomPxSg1__ (not Ess) in the beginning of a sentence.

* Nouns:  __AccPxSg1__ after a TV verb. Exception for Aux.

*Nouns: __PxSg2__ if SG2-V

!!Certain verb readings

!!!Cycle 1b: removing the readings that were left from the 1a rules 

!!Removing (nearly) all remaining Px readings

!!Noun or not?
!!Early possessive rule    
!!Adjectives and adverbs



!!Disambiguationg abbreviations
!!Rules relating to particular adpositions

!!Some particular subjunctions and Neg Sup

* __amasCS__ selects CS, not A or Neg Sup

* __amasA__ selects A, not CS or Neg Sup

* __amasNegSup__ selects Neg Sup, not CS or A

* __amatNegSup__ selects Neg Sup, not CS

* __dasgoCS__ selects CS, not Qst

* Removes __vaikkoAdv__ , it is always CS because of abbr: "vaikko_mii" Pron Indef

go as CS and Qst Pcle

* __standQst__ selects Pcle in standard questions

* __objQst__ selects Pcle in questions which function as object in the clause

* __subQst__ selects Pcle in questions as subordinated clause

* __vaiQst__ selects Pcle in questions with vai

* __auxQst__ selects Pcle in questions as subordinated clause, starting with AUX

* __refQst__ selects Pcle in two main clauses, the first one a question which is referred to in the second.

* __nounQst__ selects Pcle for go after noun

* __poQst__ selects Pcle for go after Po

* __killPcle__ removes all remaining Pcle for go 



!!Some particular subjunctions

* __madeCS__ for mađe/mađi and dađe/dađi

* __dadeCS__ for mađe/mađi and dađe/dađi

!!Adverb rules

!!!Mapping of COMP-CS< , Complements of particles in comparison

* __ComptimeAdvl__ buoret go ovdal

* __Compadvlcase__ eará sivas go fuorrávuođas

* __Compvejolas__ go vejolaš

* __compNomHead__ NP-HEAD-NOM (ADVL) go NP-HEAD-NOM (ADVL). VFIN-NOT-IMPRT pga manglende disamgiguering

* __CompNomHead__ Comp NP-HEAD-NOM leat go NP-HEAD-NOM  


* __compMisc__ go geassebuođut, go dán áigge

* __compInf__ Inf go Inf


* __Compdego__ dego @COMP-CS<

* __compAccdego__ Acc dego Acc

* __compTVeambbo__ TRANS-V eambbo go Num Acc + Gen


* __compCoord__ coordination	

* __compCoordAttr__ coordination again, now with Attr. Speacial rule because of that Attr also has other readings.	


* __killAllnotComp__ Removes analysis which are not @COMP-CS<

* __goCSbeforeComp__ Selects CS analysis in front of @COMP-CS<

!!!Mapping of CC and CS

* __cnpCompSC__ Map @CNP if @COMP-CS< or COMPAR ahte


* __CSasCNPCVP__ Map some CSs both @CNP @CVP

* __CSasCVP__ Map @CVP to CS

* __CCasCNPCVP__ Map (@CNP @CVP) to CC

* __ahteCNP__ ahte CC @CNP, remove the rest

* __killAllahtenotCS__ All other occurrences of "ahte" are CSs.

* __vaiCCCNP__ vai as CC or CS

* __vaiCC__ remove vai as CC 

* __vaiCCNegQst1__ vai CC @CVP before Neg or question

* __vaiCCNegQst2__ vai CC @CNP in question about two alternatives

__killAllvainotCSCVP__ Select all vai CS @CVP	

__dadeCNP__ removes dađe @CNP, so @CVP remains

__CVPnoVfin__ No potential finite verb following

__CVPnoVfinAdvl__ No finite verb in front ADVLCASE @CNP ADVLCASE	

__CVPNPron__ No finite verb or verbalactivity in front N/Pron @CNP N/Pron	

* __CVPAdvNom__ Nom @CNP Adv Nom	

* __CVPCopNomInf__ COPULAS Nom @CNP Nom Inf	


 *__CVPoppramsing__ Lásse, Iŋgá ja mun


*__CVPRCmpnd__ RCmpnd @CNP

* __CVPwrongCmpnd__ wrongly formated compounds

* __CVPAAttr__ A Attr @CNP A Attr	

* __CVPA__ A @CNP A 	


* __CVPAccAdv__ Acc @CNP Adv Acc	

* __killAllCNP__ removes all remaining @CNP

* __XCC-CS__ removes CC and CS with no synttag



!!!PRONOUNS
!!Disambiguating pronouns 

!!Emphatic ieš     

!!!PRONOUNS
!!Reciprocal pronouns
!!Numerals
!!More pronouns
!!Indefinite pronouns
!!Demonstrative pronouns
!!Disambiguating adjectives 

!!!MISC 
!!And now some rules for adverbs that modify adjectives
!!Proper nouns

!!!VERBS

!!Disambiguating verbs - part 1 

First ConNeg forms, they are dependent upon Neg verbs. Then Imperative 
(with their special syntax), infinitive, and other infinite forms. 
Person comes later (in part 2)



!!ConNeg forms

* __ConNegImp__ selects ConNeg Imprt if Neg Imprt to the left.

* __ConNegIfNeg__ selects Ind ConNeg if Neg Ind to the left. This is the main (and common) ConNeg rule.

* __ConNegCondIfNeg__ selects Cond ConNeg if Neg Cond to the left. Less used, obviously.







* __NotConNegII__ removes ConNegII if no Neg Imprt around. This is important, as the homonym forms are common.



* __NotConNegIfNotNeg__ removes ConNeg if no Neg to the left. Consider unifying with NotConNegNotNeg.

* __NotConNegNotNeg__ removes remaining ConNegs whenever no Neg to the left.






!!Imperative

See also ''Imprt or Ind'' some sections down.

* __ImprtLeat__ 

* __ImprtDál__ 


* __ImprtComma__ 

* __ImprtNotVGen__

* __NotImprtInd__ 

* __NotImprtConNeg__ 

* __NotImprtA__ 

* __NotImprtN__ 


* __NotImprtVFIN__ 


* __NotImprtSlash__ 


* __NotImprtGo__ 


!!Infinitive

This section still not evaluated

* __r1809__ Not Pl1 (but Inf) if VFIN to the left, This is the basic Inf rule.

* __InfCompCs__ 

* __r1811__ 

* __r1812__ 

* __r1813__ 

* __r1814__ 

* __r1815__ 



Rules that prevent later selection of Inf for a finite verb in the frame 						  
''INF-V...CC...''

* __r1816__ 
* __r1817__ 

* __r1818__ 
* __r1819__ 


* __r1820__ 

* __r1821__ 



* __r1822__ 

* __r1823__ 

* __r1824__ 

* __r1825__ 

* __r1826__ 

* __r1827__ 
* __r1828__ 

* __r1829__ 

* __r1830__ 

* __r1831__ 

* __r1832__ 

* __r1833__ 


!!Verbgenitive
!!Supinum vs. potential
!!Perfect Participle
!!Actio
!!Present participle
*orrut vs. orrot) 
!!Rules for "addit" (which is an adjective, but more often a verb)
!!Actio Loc = Actio Ess
!!Actio Gen = Actio Ess
!!Imprt or Ind



* __removeAllImp__


!!Nouns vs. verbs

!!!Verb mappings

!!!NOUNS
!!Disambiguating nouns 
!!Nouns vs. adjectives
!!Disambiguating proper nouns 

!!NOMEN
!!!Case disambiguation

!!Secure rules for choosing Acc

!Intransitive verbs can sometimes be transitive






!!Intransitive verbs can sometimes be transitive
!!Accusative or genitive in front of ALU and in front of adjectives
!!Accusative before @COMP-CS<
!!Accusative before some A
!!Accusative sentence-finally
!!Genitive and accusative in temporal adverbials
!!Choosing accusative or genitive semantically
!!Genitive

The most frequent genitive rule: Gen when postpos immediately to the right:



!!Nominative and accusative
!!Nominative

!!Accusative

!!Illative

!!Early comitative rules

!!Locative

!!Essive  
!!Late case rules (after other case rules have worked). 

!!!VERBS
!!Finite or not
!!Indicative or imperative
!!Verbs according to person and number
!!Rules for a special infinitive construction
!!More finite verbs
!!Passive
!!Infinitive
!!Present Participle
!!Actio/Perfect Participle 
!!Actio
!!Selecting some more finite verbs
!!Lexical disambiguation of verbs 

!!!NOMEN
!!Case rules
!!Other rules for nouns and pronouns
!!Px rules
!!Determiners
!!Adverbs and adjectives

!!!NOUNS
!!Nouns

!!!VERBS
!!Verbs

!!!NOMEN


!!Genitive after preposition -- round 2
*MAINLY MAPPING-RULES #####









