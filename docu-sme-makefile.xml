<?xml version = '1.0' encoding = 'UTF-8'?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
  <header>
    <title>A documentation of the sme Makefile</title>
  </header>
  <body>
    <section id="A_documentation_of_the_sme_Makefile" >
      <title>A documentation of the sme Makefile</title>
      <section id="The_Makefile_itself" >
        <title>The Makefile itself</title>
        <p>The Makefile is organized as follows: It contains of a number of blocks, each block builds one binary file. Each binary file is dependent upon a number of other files. The first line of each block, the dependency line, mentions the target file, a colon, and the address of the dependency file. On the next line comes the file with address, thereafter again a colon, and after the colon the dependency files are listed. The dependency line can go over several lines with the backslash character (\). In the first block, the dependency lines look as follows:</p>
        <source>isme.fst: ../bin/isme.fst
../bin/isme.fst: ../bin/sme.fst ../bin/sme.save ../bin/tok.fst \
        ../bin/allcaps.fst
</source>
        <p>After the dependency line comes the actions themselves. In the Makefile, each line is initiated with a TAB character. Commands are initiated with the &quot;@&quot; character, and arguments delimited with quotes. Quotes within the quotes are preceded by \.</p>
        <p>The commands are initiated by an informative banner printed to the screen. Then comes the actions. They are printed to a temporary script file (in the first block, the file is &quot;isme-fst-script&quot;, by the @printf command. Then the relevant program (e.g. the program xfst in the first block of the sme Makefile) reads the scriptfile and executes it. Finally, the temporary script file is removed by the @rm command. The makefiles for the other languages are made in the same way.</p>
        <p>Note that the source files are taken from the src directory (and referred to by filenames only, since the Makefile itself is in the src directory), whereas the binary files are taken from the bin directory, and hence prefixed with '../bin/'.</p>
        <section id="lookup_the_lookup_scripts" >
          <title>lookup: the lookup scripts</title>
          <p>No lookup scripts are written. They should be, to make it easier to analyse files.</p>
        </section>
        <section id="The_preprocessor" >
          <title>The preprocessor</title>
          <p>The sme Makefile contains target for generating a file <code>abbr.txt</code> which contains a list of abbreviations used in the preprocessing phase. The file is generated by script <code>abbr-extract</code> which is located in <code>gt/script</code> directory. It gets as a command line parameter the main abbreviation file and then a list of files from where multiword expressions should be searched for. Basically:</p>
          <source>abbr.txt: ../bin/abbr.txt
../bin/abbr.txt: ../../script/abbr-extract abbr-sme-lex2.txt \
        propernoun-sme-lex.txt closed-sme-lex.txt adv-sme-lex.txt

        abbr-extract --abbr_lex=abbr-sme-lex2.txt \
        --lex=propernoun-sme-lex.txt,closed-sme-lex.txt,adv-sme-lex.txt \
        --output=../bin/abbr.txt
</source>
        </section>
      </section>
      <section id="If_one_ever_should_need_to_manage_without_make..." >
        <title>If one ever should need to manage without make...</title>
        <p>In case the actual commands themeselves are sometimes needed: This is a list of the commands that were needed to build a morphological parser before the time of the makefile.</p>
        <source>exchange &quot;sme&quot; for other lg (smj, sms)

Compiling the parser
====================

in twolc (open by typing &quot;twolc&quot;)
---------------------------------
read-grammar twol-sme.txt
compile
save-binary twol-sme.bin

in lexc (open by typing &quot;lexc&quot;)
-------------------------------
compile-source *-sme.txt
or: run-script skript1 (smj has script file &quot;lskr&quot;, sms has no script file)
read-rules twol-sme.bin
compose-result
save-result sme.save

in xfst (open by typing &quot;xfst&quot;)
-------------------------------
load stack caseconv.fst 
load stack sme.save 
compose net
save stack sme.fst

The tok.fst tokenizer is also built in xfst:
--------------------------------------------
read-regex &lt; case.regex
save stack caseconv.fst
</source>
        <p>
<!-- hhmts start -->Last modified: Thu Sep 19 20:58:22 CEST 2002 <!-- hhmts end -->        </p>
      </section>
    </section>
  </body>
</document>
